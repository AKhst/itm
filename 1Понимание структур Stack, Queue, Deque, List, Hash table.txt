https://aliev.me/runestone/BasicDS/WhatisaStack.html - структуры данных 
Множество в Python - это неупорядоченная коллекция уникальных элементов. Оно не поддерживает дублирование элементов, и порядок элементов в множестве не гарантирован. Важно отметить, что множества используются для выполнения операций над уникальными элементами, таких как удаление дубликатов, проверка на пересечение и т. д. Оно может быть создано с использованием фигурных скобок { } или функции set(). 

Основные характеристики множеств в Python:
add(): Добавляет элемент в множество.
python
my_set = {1, 2, 3}
my_set.add(4)

remove(): Удаляет элемент из множества. Если элемент отсутствует, вызывает ошибку.
python
my_set = {1, 2, 3}
my_set.remove(2)

discard(): Удаляет элемент из множества. Если элемент отсутствует, не вызывает ошибку.
python
my_set = {1, 2, 3}
my_set.discard(2)

union(): Возвращает множество, содержащее все уникальные элементы из обоих множеств.
python
set1 = {1, 2, 3}
set2 = {3, 4, 5}
union_set = set1.union(set2)

intersection(): Возвращает множество, содержащее уникальные элементы, присутствующие в обоих множествах.
python
set1 = {1, 2, 3}
set2 = {3, 4, 5}
intersection_set = set1.intersection(set2)

difference(): Возвращает множество, содержащее уникальные элементы, присутствующие только в одном из множеств.
python
set1 = {1, 2, 3}
set2 = {3, 4, 5}
difference_set = set1.difference(set2)

symmetric_difference(): Возвращает множество, содержащее уникальные элементы, присутствующие только в одном из множеств, но не в обоих.
python
set1 = {1, 2, 3}
set2 = {3, 4, 5}
symmetric_difference_set = set1.symmetric_difference(set2)

issubset(): Проверяет, является ли одно множество подмножеством другого.
python
set1 = {1, 2}
set2 = {1, 2, 3, 4}
is_subset = set1.issubset(set2)

issuperset(): Проверяет, является ли одно множество надмножеством другого.
python
set1 = {1, 2, 3, 4}
set2 = {1, 2}
is_superset = set1.issuperset(set2)

copy(): Создает копию множества.
python
Copy code
my_set = {1, 2, 3}
new_set = my_set.copy()

Проверка на вхождение: Методы in и not in используются для проверки вхождения элемента в множество.
python
my_set = {1, 2, 3}
print(1 in my_set)  # Выводит: True

Размер множества: Метод len() возвращает количество элементов в множестве.
python
my_set = {1, 2, 3}
print(len(my_set))  # Выводит: 3

A.isdisjoint(B) - это метод множеств в Python, который возвращает True, если два множества не имеют общих элементов. Если у множеств есть хотя бы один общий элемент, метод вернет False.

python
set1 = {1, 2, 3}
set2 = {4, 5, 6}
result = set1.isdisjoint(set2)
print(result)  # Вывод: True (нет общих элементов)

1) Понимание структур Stack, Queue, Deque, List, Hash table  Stack https://youtu.be/L4IU1bPKvHM?feature=shared: - start 18/00

Stack - это упорядоченная коллекция элементов, где добавление нового или удаление существующего всегда происходит только на одном из концов. Этот конец обычно называют “вершиной”, а противоположный ему - “основанием”.
Такой принцип организации иногда называется LIFO, last-in, first-out (англ. «последним пришёл — первым вышел»). 
Операции:
push: добавляет элемент на вершину стека.
pop: удаляет элемент с вершины стека.
peek (или top): возвращает элемент с вершины стека без удаления.
Примеры применения: управление вызовами функций, обратная запись выражений, реализация истории действий в программе.

Queue - это упорядоченная коллекция элементов, в которой добавление новых происходит с одного конца, называемого “хвост очереди”, а удаление существующих - с другого, “головы очереди”. Как только элемент добавляется в конец очереди, он начинает свой путь к её началу, ожидая удаления предыдущих.

Самые последние из добавленных в очередь единиц должны ждать в конце коллекции. Элемент, который пробыл в очереди дольше всего, находится в её начале. Такой принцип упорядочения иногда называют FIFO, first-in first-out (англ. “первым пришёл - первым вышел”). Ещё он известен, как “первым пришёл - первым обслужен”.

Операции:
enqueue: добавляет элемент в конец очереди.
dequeue: удаляет элемент из начала очереди.
front: возвращает элемент в начале очереди без удаления.
Примеры применения: управление задачами, буферизация ввода/вывода, реализация алгоритмов поиска в ширину.

Deque - также называемый двусторонней очередью, - это упорядоченная коллекция элементов, подобная очереди. Он имеет два конца (голову и хвост), и его элементы остаются позиционированными. Что отличает дек, так это нестрогая природа добавления и удаления его составляющих. Новые элементы могут быть добавлены как в голову, так и в хвост. Аналогично, существующие компоненты могут удаляться из обоих концов. В каком-то смысле, этот гибрид линейной структуры объединяет все возможности стеков и очередей. 
Двусторонняя очередь позволяет добавлять и удалять элементы как с начала, так и с конца.

Операции:
push_front: добавляет элемент в начало.
push_back: добавляет элемент в конец.
pop_front: удаляет элемент с начала.
pop_back: удаляет элемент с конца.
Примеры применения: реализация стека и очереди, алгоритмы обработки данных с обоих концов.

List - коллекция элементов, каждый из которых хранится на соответствующей позиции по отношению к остальным. Точнее, список такого рода мы будем называть упорядоченным списком. Можно сделать вывод, что список имеет первый элемент, второй элемент, третий и так далее. Мы также можем ссылаться на начало списка (первый элемент) или его конец (последний элемент). Для простоты будем полагать, что списки не содержат дублирующихся данных. Список может быть реализован как связанный список, массив, динамический массив и другие структуры.
Операции могут варьироваться в зависимости от типа списка, но обычно включают добавление, удаление и поиск элементов.
Примеры применения: хранение и управление коллекциями данных, реализация стека и очереди, обработка последовательных данных.

Hash Table - это коллекция элементов, которые сохраняются таким образом, чтобы позже их было легко найти. Каждая позиция в хэш-таблице (часто называемая слотом) может содержать собственно элемент и целое число, начинающееся с нуля. Например, у нас есть слот 0, слот 1, слот 2 и так далее. Первоначально хэш-таблица не содержит элементов, так что каждый из них пуст. Мы можем сделать реализацию хэш-таблицы, используя список, в котором каждый элемент инициализирован специальным значением Python None. Связь между элементом и слотом, в который он кладётся, называется хэш-функцией. Она принимает любой элемент из коллекции и возвращает целое число из диапазона имён слотов (от 0 до \(m-1\)). Предположим, что у нас есть набор целых чисел 54, 26, 93, 17, 77 и 31. Наша первая хэш-функция, иногда называемая “методом остатков”, просто берёт элемент и делит его на размер таблицы, возвращая остаток в качестве хэш-значения (\(h(item)=item \% 11\)).Хеш-таблица использует хеш-функцию для преобразования ключей в индексы массива.
Операции:
вставка: добавляет значение с ключом.
поиск: находит значение по ключу.
удаление: удаляет значение по ключу.
Примеры применения: реализация словарей, множеств, оптимизация поиска данных.

2) Алгоритм сортировки пузырьком - Сравнение и обмен элементов: Алгоритм сортировки пузырьком базируется на сравнении двух соседних элементов в массиве и, при необходимости, обмене их местами. Если текущий элемент больше следующего, то они меняются местами. Проходы по массиву: Сортировка пузырьком выполняет несколько проходов по массиву. В каждом проходе наибольший элемент "всплывает" на свое место в конце массива. Временная сложность: прост в реализации но не эффективен для больших массивов. 

Алгоритм сортировки вставками - Вставка элементов на свои места: Сортировка вставками начинает с первого элемента, считая его уже отсортированным, и затем поочередно вставляет каждый следующий элемент на свое место среди уже отсортированных элементов. Итерация по всем элементам: Внешний цикл итерирует по всем элементам массива, начиная со второго. Перемещение элементов влево: Внутренний цикл перемещает текущий элемент влево, пока не найдется правильное место для вставки. Временная сложность: В среднем и в худшем случае алгоритм также имеет временную сложность O(n^2). Он более эффективен, чем сортировка пузырьком, но все равно не оптимальный для больших массивов.

Оба эти алгоритма предназначены для упорядочивания элементов в массиве, но сортировка пузырьком сравнивает и меняет соседние элементы, чтобы "вытолкнуть" наибольший элемент в конец, в то время как сортировка вставками вставляет каждый элемент на правильное место среди отсортированных элементов.

3) Алгоритмы поиска 
Линейный поиск — это простой алгоритм, который перебирает каждый элемент в наборе данных (например, в массиве) и сравнивает его с целевым значением. Если элемент найден, алгоритм возвращает его индекс (или значение); в противном случае, он вернет информацию о том, что элемент не был найден.
Пример линейного поиска:
def linear_search(arr, target):
    for i in range(len(arr)):
        if arr[i] == target:
            return i  # Возвращаем индекс элемента, если он найден
    return -1  # Возвращаем -1, если элемент не найден

my_list = [5, 2, 9, 3, 8, 1, 6, 7, 4, 10]
target = 6
result = linear_search(my_list, target)
if result != -1:
    print(f"Элемент {target} найден по индексу {result}")
else:
    print(f"Элемент {target} не найден")
Бинарный поиск - это эффективный алгоритм поиска элемента в отсортированном массиве или списке. Алгоритм работает путем деления массива пополам и сравнения искомого элемента с элементом в середине. Если элемент совпадает с серединой, поиск завершается. Если искомый элемент меньше, чем элемент в середине, поиск продолжается в левой половине массива; если искомый элемент больше, чем элемент в середине, поиск продолжается в правой половине.
Пример Бинарного поиска:
def binary_search(arr, target):
    left, right = 0, len(arr) - 1
    
    while left <= right:
        mid = left + (right - left) // 2
        
        if arr[mid] == target:
            return mid  # Искомый элемент найден, возвращаем его индекс
        elif arr[mid] < target:
            left = mid + 1  # Искомый элемент находится в правой половине
        else:
            right = mid - 1  # Искомый элемент находится в левой половине
    
    return -1  # Искомый элемент не найден

# Пример использования
arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]
target = 6
result = binary_search(arr, target)

if result != -1:
    print(f"Искомый элемент {target} найден по индексу {result}")
else:
    print(f"Искомый элемент {target} не найден")


4) Big O notation: сложность операции чтение/запись n-ного элемента из структур Stack, Queue, Deque, List, Hash table
Большая O-нотация может быть использована для анализа временной сложности алгоритмов для различных структур данных. Разные структуры данных обладают разными характеристиками, и операции над ними могут иметь разные временные сложности. Вот некоторые общие структуры данных и их типичные временные сложности в нотации "Большая O" для различных операций:

Связанные списки:
Доступ (по индексу): O(n)
Поиск: O(n)
Вставка/Удаление в начале: O(1)
Вставка/Удаление в конце: O(1), если имеется указатель на хвост; O(n) в противном случае
Вставка/Удаление в произвольном узле: O(1), если у вас есть ссылка на узел; O(n), если сначала нужно выполнить поиск

Стеки и очереди (реализованные с использованием массивов или связанных списков):
Добавление (для стеков)/Вставка (для очередей): O(1)
Извлечение (для стеков)/Удаление (для очередей): O(1)

Хеш-таблицы:

Вставка: O(1) в среднем, но O(n) в худшем случае (разрешение коллизий может быть сложным)
Поиск: O(1) в среднем, но O(n) в худшем случае
Удаление: O(1) в среднем, но O(n) в худшем случае

При выборе структуры данных для конкретного приложения следует учитывать конкретные операции, которые часто выполняются, и ожидаемые сценарии использования. Цель состоит в выборе структуры данных, которая минимизирует общую вычислительную сложность для вашего конкретного случая.

Stack (стек): Стек - это структура данных, в которой элементы хранятся в порядке "последний вошел, первый вышел" (Last-In-First-Out, LIFO). Это означает, что вы можете быстро получить доступ только к верхнему элементу стека, и для доступа к другим элементам вам придется извлечь элементы сверху.

Queue (очередь): Очередь - это структура данных, в которой элементы хранятся в порядке "первый вошел, первый вышел" (First-In-First-Out, FIFO). Вы можете получить быстрый доступ только к первому элементу, и для доступа к другим элементам придется извлекать элементы в порядке, в котором они находятся в очереди.

Deque (двусторонняя очередь): Двусторонняя очередь по сути сочетает в себе черты стека и очереди. Вы можете добавлять и удалять элементы как с начала, так и с конца. Однако, для доступа к элементам, находящимся далеко от начала или конца, придется пройти через другие элементы.

List (список): Список в Python - это универсальная структура данных, которая предоставляет быстрый доступ к элементам по индексу. Это означает, что вы можете быстро получить доступ к любому элементу, зная его индекс.

Hash table (хэш-таблица): Хэш-таблица использует хеш-функцию для быстрого поиска элементов по ключу. В среднем случае, доступ к элементу в хэш-таблице также быстрый, но при возникновении коллизий (когда разные ключи имеют одинаковый хеш) может потребоваться больше времени.

Итак, важно выбирать структуру данных в зависимости от конкретных потребностей вашей программы. Например, если вам нужно быстро получить доступ к элементу по индексу, то список (List) является хорошим выбором. Если вам нужно управлять элементами в определенном порядке, то стек (Stack) или очередь (Queue) могут быть более подходящими.

5) Dict/List/Set comprehension,
Dict/List/Set comprehension в Python - это удобный способ создать новый словарь (dict), список (list) или множество (set) путем преобразования или фильтрации существующей коллекции данных. Они представляют собой сокращенный и выразительный способ создания новых структур данных. Давайте рассмотрим их подробнее:

List Comprehension (списковое включение):
Позволяет создавать новый список на основе существующего.
Простой синтаксис в виде [выражение for элемент in коллекция if условие].

Пример:
numbers = [1, 2, 3, 4, 5]
squared_numbers = [x**2 for x in numbers if x % 2 == 0]
# squared_numbers содержит [4, 16]

Dict Comprehension (словарное включение):
Позволяет создавать новый словарь на основе существующей коллекции данных.
Синтаксис в виде {ключ: значение for элемент in коллекция if условие}.
Пример:
students = ['Alice', 'Bob', 'Charlie']
student_scores = {student: len(student) for student in students}
# student_scores содержит {'Alice': 5, 'Bob': 3, 'Charlie': 7}

Set Comprehension (множественное включение):
Позволяет создать новое множество на основе существующей коллекции данных.
Синтаксис в виде {выражение for элемент in коллекция if условие}.
Пример:
numbers = [1, 2, 2, 3, 4, 4, 5]
unique_numbers = {x for x in numbers}
# unique_numbers содержит {1, 2, 3, 4, 5}

List, Dict и Set Comprehension предоставляют более компактный и читаемый способ создания новых коллекций на основе существующих данных и часто используются в Python для этой цели.

Изменяемые типы данных (mutable):

Список (List): Список может быть изменен после создания. Вы можете добавлять, удалять и изменять элементы в списке.

Массив байтов (Bytearray): Похож на список, но представляет последовательность байтов, которую можно изменять.

Словарь (Dict): Словарь представляет ассоциативный массив, и его содержимое (пары ключ-значение) может быть изменено.

Множество (Set): Множество также может быть изменено. Вы можете добавлять и удалять элементы из множества.
В Python, структура данных Set поддерживает несколько основных операций:
Объединение: Объединение двух множеств возвращает множество, содержащее все уникальные элементы из обоих множеств.
Пересечение: Пересечение двух множеств возвращает множество, содержащее только те элементы, которые присутствуют в обоих множествах.
Дополнение (вычитание): Операция дополнения над множествами возвращает элементы из первого множества, которые не присутствуют во втором множестве.
Симметричная разность: Возвращает множество, содержащее элементы, которые присутствуют только в одном из множеств, но не в обоих.
Эти операции позволяют эффективно манипулировать уникальными элементами в множествах.

Неизменяемые типы данных (immutable):
Строка (Str): Строка не может быть изменена после создания. Вы не можете изменять символы в строке.
Кортеж (Tuple): Кортеж неизменяем. После создания кортежа нельзя изменить его содержимое.
Доступ к элементам по индексу: Элементы кортежа могут быть доступны по индексу, точно так же, как и в списках, но они не могут быть изменены.
Перестановка элементов: С помощью кортежей можно осуществлять перестановку элементов для различных операций или преобразований данных.
Сортировка: Кортежи могут быть отсортированы для упорядочивания элементов по возрастанию или убыванию.
Эти операции позволяют работать с элементами кортежей без их изменения.
Байт (Byte): Байт также является неизменяемым типом данных и представляет один байт информации.
Целое число (int) и Число с плавающей запятой (float): Эти числовые типы данных также неизменяемы.
Изменяемые типы данных могут быть полезными, когда вам нужно изменять данные внутри структуры, в то время как неизменяемые типы данных обеспечивают надежность и предсказуемость в работе с данными. Выбор между изменяемыми и неизменяемыми типами зависит от конкретной задачи и требований к вашей программе.